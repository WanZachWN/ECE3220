#include "student_functions.h"
//============================================================================================
typedef enum {true , false} bool; //type bool
//============================================================================================
//insert new student in list
Student *insert_student(Student *node, char *name, char *prev_name)
{
	Student *node_ins = (Student*)malloc(sizeof(Student));//create new node in heap
	memset(node_ins->name, '\0', sizeof(node_ins->name));//set all of insertion node to whitespace (to prevent buffer overflow)
	strcpy(node_ins->name, name);//copy student name given to the node
	
	if(node == NULL)//if list is empty
	{
		node_ins->prev = NULL;
		node_ins->next = NULL;
		node = node_ins;
	}

	else//if list is not empty
	{
		printf("\nlist not empty %s\n", node_ins->name);
		Student *traverse;

		traverse = search_list(node, prev_name);//search for prev student location
		printf("search : %s\n", traverse->name);
		
		if(traverse->next == NULL)//if last element insert at the back
		{
			traverse->next = node_ins;
			node_ins->prev = traverse;
		}
		else//insert in between
		{
			node_ins->next = traverse->next;
			traverse->next = node_ins;
			node_ins->prev = traverse;
			node_ins->next->prev = node_ins;
		}
	}
	printf("inserted %s\n", node_ins->name);
	return node;
}
//============================================================================================
//delete a student from the lsit
int delete_student(Student *node, char *name)
{
	struct Student *traverse;
	traverse = node;
	while(traverse->next != NULL)//traverse equal to null if end of node
	{
		if(strcmp(traverse->name, name) == 0)//If string compare return 0 means we found a match
		{
			if(traverse->prev == NULL)//if Student at first node
			{
				traverse = node->next;//point to next node of pointer node
				free(node);//delete current student from list
				node = traverse;//assign node to the new head in list
				node->prev = NULL;//assign previous node to NULL
				
			}
			else if(traverse->next == NULL)//if Stdent at last node
			{
				Student *temp;//temp student pointer
				traverse->prev->next = NULL;//set pointer of previous node to NULL
				free(traverse);//delete current student from list
			}
			else//Student in the middle of two nodes
			{
				traverse->prev->next = traverse->next;//change previous node of next pointer to the next node of pointer traverse
				traverse->next->prev = traverse->prev;//change next node of previous pointer to the previoucases node of pointer traverse
				free(traverse);//delete current student from list
			}
			return 1;//return 1 if we succeed in finding the sstudent and delete it
		}
		else
		{
			traverse = traverse->next;//iterate to next node
		}
	}
	return 0;//return if we could not find the student in list to delete
}
//============================================================================================
//search the student
Student *search_list(Student *node, char *name)
{
	Student *find;
	find = node;
	while(find != NULL)//if find is not pointing to NULL(end of node) then loop
	{
		if(strcmp(find->name, name) == 0)//If string compare return 0 means we found a match and it will give the first student with that name
		{
			printf("found\n");
			return find;//return the current node find is pointing to
		}
		find = find->next;//iterate to the next node
	}
	printf("student is not in list\n");
	return NULL;//return NULL if student is not in the list
}
//============================================================================================
//swap two students in list
Student *swap(Student *node1, Student *node2)
{
	Student *temp = node1->prev;//temp pointer of type student
	
	//if one of them does not exist
	if(node1 == NULL || node2 == NULL)
	{
		return NULL;
	}
	
	//if both of them are at the end
	if(node1->prev == NULL && node2->next == NULL || node1->next == NULL && node2->prev == NULL)
	{
		//next to each other
		if(node1->next == node2)		
		{
			temp = node1->prev;
		}
		else if(node2->next == node1)
		{

		}
		//if node1 at last then node2 at first
		if(node1->next == NULL)
		{
			
		}
		//if node2 at last and node1 at first
		else
		{
			temp = node2->prev;
			
			return node2;
		}
	}
	
	else
	{
		//temp points to the node after node1 and assign the previous to node2
		temp = node1->next;
		temp->prev = node2;
		
		//temp points to the node previous node2 and assign the next pointer to node1
		temp = node2->prev;
		temp->next = node1;
		
		//temp points to the node before node1. Assign the previous pointer of node1 to previous pointer of node2. Change previous pointer of node2 to the node temp points to. 
		temp = node1->prev;
		node1->prev = node2->prev;
		node2->prev = temp;
		temp->next = node2;
		
		//temp points to thcasee node after node2. Assign the previous pointer of temp to node1. Next pointer of node2 points to next pointer of node1. Next pointer of node1 points to the node temp points to.
		temp = node2->next;
		temp->prev = node1;
		node2->next = node1->next;
		node1->next = temp;
	}
	return node2;
	
}
//============================================================================================
//empty doubly linked-list
void free_list(Student *node)
{
	Student *temp; //temp pointer
	while(node != NULL)//when both of this is NULL then stop
	{
		temp = node;// point temp to node of pointer node
		node = temp->next;//point node to next
		free(temp);//free temp
	}
	return;//go back to main
}

//===========================================================================================
//display the whole linked list
void display(Student *node)
{
	struct Student *traverse = node;
	if(node == NULL)//if list is empty
	{
		printf("List is empty\n");
		return;
	}
	else//if list is not empty
	{
		printf("Displaying: \n");
		//traverse the whole loop
		while(traverse != NULL)
		{
			//if not last element
			if(traverse->next != NULL)
			{
				printf("%s->", traverse->name);
			}
			//if last element
			else
			{
				printf("%s\n", traverse->name);
			}
			traverse = traverse->next;//traverse list
		}
	}
	return;
}
//============================================================================================
//main function
int main()
{
	struct Student *head = (struct Student*)malloc(sizeof(struct Student));
	head = NULL;
	
	display(head);
	
	head = insert_student(head, "zach" , "");//head->zach
	display(head);

	head = insert_student(head, "jake" , "zach");//head->zach->jake
	display(head);
	
	insert_student(head, "bob" , "zach");//head->zach->bob->jake
	display(head);
	
	insert_student(head, "carl" , "jake");//head->zach->bob->jake->carl
	display(head);
	display_back(head);
	if(delete_student(head, "llama") == 1)//head->zach->jake->carl->
	{
		printf("deletion successful\n");
		display(head);
	}
	else
	{
		printf("Error! student could not be found\n");
	}
	if(delete_student(head, "jake") == 1)//head->zach->jake->carl->
	{
		printf("deletion successful\n");
		display(head);
	}
	else
	{
		printf("Error! student could not be found\n");
	}
	
	free_list(head);
	display(head);
	
	//head = swap(search_list(head, "zach"), search_list(head, "carl"));//head->carl->bob->zach->jake
	//display(head);
	
	
	
	return 0;
}
